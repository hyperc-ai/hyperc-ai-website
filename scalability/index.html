<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Scalability - HyperC</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Scalability | HyperC</title> <meta name="generator" content="Jekyll v4.2.1" /> <meta property="og:title" content="Scalability" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="HyperC is the autonomous planning database." /> <meta property="og:description" content="HyperC is the autonomous planning database." /> <link rel="canonical" href="https://hyperc.ai/scalability/" /> <meta property="og:url" content="https://hyperc.ai/scalability/" /> <meta property="og:site_name" content="HyperC" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Scalability" /> <script type="application/ld+json"> {"@type":"WebPage","url":"https://hyperc.ai/scalability/","headline":"Scalability","description":"HyperC is the autonomous planning database.","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="https://hyperc.ai/" class="site-title lh-tight"> HyperC </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="https://hyperc.ai/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="https://hyperc.ai/documentation/" class="nav-list-link">Documentation</a></li><li class="nav-list-item"><a href="https://hyperc.ai/architecture/" class="nav-list-link">Architecture</a></li><li class="nav-list-item active"><a href="https://hyperc.ai/scalability/" class="nav-list-link active">Scalability</a></li><li class="nav-list-item"><a href="https://hyperc.ai/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search HyperC" aria-label="Search HyperC" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="//github.com/hyperc-ai" class="site-button" target="_blank" rel="noopener noreferrer" > HyperC on GitHub </a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content" role="main"> <details open=""> <summary class="text-delta"> Table of contents </summary> <ol id="markdown-toc"> <li><a href="#scalability-challenge" id="markdown-toc-scalability-challenge">Scalability Challenge</a> <ol> <li><a href="#what-is-a-scalability-problem" id="markdown-toc-what-is-a-scalability-problem">What is a Scalability Problem?</a></li> </ol> </li> <li><a href="#previous-approaches" id="markdown-toc-previous-approaches">Previous Approaches</a> <ol> <li><a href="#multiagent-systems" id="markdown-toc-multiagent-systems">Multiagent Systems</a></li> <li><a href="#gpu-based-methods" id="markdown-toc-gpu-based-methods">GPU-based Methods</a></li> <li><a href="#lp--and-sat--based-methods" id="markdown-toc-lp--and-sat--based-methods">LP- and SAT- based Methods</a></li> <li><a href="#hierarchical-task-networks" id="markdown-toc-hierarchical-task-networks">Hierarchical Task Networks</a></li> </ol> </li> <li><a href="#our-approach" id="markdown-toc-our-approach">Our Approach</a> <ol> <li><a href="#the-task" id="markdown-toc-the-task">The Task</a></li> <li><a href="#select-the-right-formalism" id="markdown-toc-select-the-right-formalism">Select the Right Formalism</a></li> <li><a href="#scaling-problem-in-strips-formalism" id="markdown-toc-scaling-problem-in-strips-formalism">Scaling Problem in STRIPS formalism</a></li> <li><a href="#scaling-mechanisms-that-work" id="markdown-toc-scaling-mechanisms-that-work">Scaling Mechanisms that Work</a> <ol> <li><a href="#low-hanging-fruits" id="markdown-toc-low-hanging-fruits">Low-hanging Fruits</a></li> </ol> </li> <li><a href="#tested-methods-not-yet-in-production" id="markdown-toc-tested-methods-not-yet-in-production">Tested Methods not yet in Production</a></li> <li><a href="#methods-from-literature-but-not-fully-tested-yet" id="markdown-toc-methods-from-literature-but-not-fully-tested-yet">Methods from literature but not fully tested yet</a></li> <li><a href="#novel-work-not-in-production-yet" id="markdown-toc-novel-work-not-in-production-yet">Novel Work not in production yet</a></li> <li><a href="#not-distant-future" id="markdown-toc-not-distant-future">Not-distant Future</a></li> </ol> </li> <li><a href="#remark-on-plan-optimality" id="markdown-toc-remark-on-plan-optimality">Remark on Plan Optimality</a></li> </ol> </details> <h1 id="scalability-challenge"> <a href="#scalability-challenge" class="anchor-heading" aria-labelledby="scalability-challenge"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Scalability Challenge </h1> <p>Planning problems are known to scale poorly with conventional approaches. They require extreme amounts of RAM and compute to create plans with the real-world dataset. This document briefly discusses HyperC approach to the scalability challenge of the planning database.</p> <h3 id="what-is-a-scalability-problem"> <a href="#what-is-a-scalability-problem" class="anchor-heading" aria-labelledby="what-is-a-scalability-problem"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What is a Scalability Problem? </h3> <ul> <li>Planning 10 items delivery with 10 steps takes 10MB of RAM and 30 seconds</li> <li>Planning 1000 items with 20 steps needs 1’000’000 MB or RAM and 3e10 seconds</li> </ul> <p>In other words, state-space grows very fast with the amount of data that needs to be processed.</p> <h1 id="previous-approaches"> <a href="#previous-approaches" class="anchor-heading" aria-labelledby="previous-approaches"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Previous Approaches </h1> <p>Other than applying a hardcoded domain-specific method for a particular sub-problem, several universal approaches are in use for solving planning problems:</p> <h2 id="multiagent-systems"> <a href="#multiagent-systems" class="anchor-heading" aria-labelledby="multiagent-systems"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multiagent Systems </h2> <p>The idea is to define a problem with independent “agents” that communicate and make decisions independently. It is very easy to scale multi-agent task to many CPUs. The issue is that very few real-world processes act like independent agents and even if agents are present, the “actions” of the agents are highly dependent on each other. Additionally, multi-agent programming requires more brainpower than free-form modeling and is not popular.</p> <h2 id="gpu-based-methods"> <a href="#gpu-based-methods" class="anchor-heading" aria-labelledby="gpu-based-methods"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> GPU-based Methods </h2> <p>Various GPU-based methods are under development. The challenge with applying GPUs is that GPUs have a specific architecture optimized for thousands of threads that must operate under the same execution flow branch. Whenever the threads stop being “in sync” the vectorized execution breaks and performance falls back to single-threaded. A typical planning problem is about exploring many different branches, so advanced trickery is required to set up such a task for the GPU. This makes crafting an efficient GPU-bound planning task extra challenging and could be intractable for humans to complete without a universal task translator, which does not exist yet.</p> <h2 id="lp--and-sat--based-methods"> <a href="#lp--and-sat--based-methods" class="anchor-heading" aria-labelledby="lp--and-sat--based-methods"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> LP- and SAT- based Methods </h2> <p>An approach based on scalable LP- and SAT- solvers is the most widespread among the Operations Research community. It also provides the most performing solutions without any additional compute-heavy training or tuning step. The downside is that a specific skillset and experience is required to convert any real-world problem into an LP or SAT formalism. Additionally, any seemingly insignificant change to the problem definition may require a complete rewrite of the solution, multiplying the time and cost to develop.</p> <h2 id="hierarchical-task-networks"> <a href="#hierarchical-task-networks" class="anchor-heading" aria-labelledby="hierarchical-task-networks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hierarchical Task Networks </h2> <p>HTNs have seen the most success as a universal approach to scalable planning in various applications. The downside is that it combines the features and issues of the above methods. It requires high engagement of the developer into managing and hand-tuning the problem definition and also experience that is hard to obtain quickly.</p> <h1 id="our-approach"> <a href="#our-approach" class="anchor-heading" aria-labelledby="our-approach"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Our Approach </h1> <p>HyperC takes a novel approach to the problem that can be nicknamed as “decompose and reuse”.</p> <p>Decompose means that we split the problem into many smaller sub-problems. The major implementation of this principle is in the “gradual grounding” approach where the highest-level expressivity construct (the database engine query) is being interpreted as a set of Python statements, then the ambiguities in Python variables are interpreted, and so on…</p> <p>Reuse means that we use the system to optimize itself. The planning problem can be expressed as a planning problem. The automatic proof can be expressed as a planning problem, and so on. So we solve the planning problem and reuse the solver recursively.</p> <h2 id="the-task"> <a href="#the-task" class="anchor-heading" aria-labelledby="the-task"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Task </h2> <ol> <li>Given the poorly defined problem in expressive and non-deterministic formalism - optimize it for better performance</li> <li>Given we have a solution for small amount of items/trucks/logic steps, figure out how to solve for larger amount.</li> </ol> <p>The first definition comes from the fact that it is very hard to isolate a “pure” problem from a real-world process so we expect the original definition to have unnecessary actions, effects, and missing “obvious” constraints. The model of the domain itself will have unnecessary detail that will pollute the heap with irrelevant or redundant facts and statements.</p> <p>The second subtask is about learning to solve smaller problems and applying the knowledge to try to solve larger onces.</p> <h2 id="select-the-right-formalism"> <a href="#select-the-right-formalism" class="anchor-heading" aria-labelledby="select-the-right-formalism"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Select the Right Formalism </h2> <p>HyperC uses:</p> <ul> <li>STRIPS formalism</li> <li>Strictly first-order logic</li> <li>Filter everything through a layer of a subset of PDDL</li> </ul> <p>This allows us to apply a large corpus of research and algorithms that exists in AI planning domain. For example it has been shown that sound plans can always be found if enough states (interpretations) are grounded.</p> <h2 id="scaling-problem-in-strips-formalism"> <a href="#scaling-problem-in-strips-formalism" class="anchor-heading" aria-labelledby="scaling-problem-in-strips-formalism"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Scaling Problem in STRIPS formalism </h2> <p>In STRIPS, we can define the scaling problem with two statements:</p> <ol> <li>Find smaller grounding to be able to do an exhaustive search</li> <li>Use universal heuristics to search better than blind</li> </ol> <p>It is easy to see that the smaller state-space resulting from fewer interpretations will allow to solve the problem much faster even without any additional heuristics. The universal heuristics can be applied from existing research as well as machine-learned on a concrete problem, a set of problems or universally with domain-independent embedding.</p> <h2 id="scaling-mechanisms-that-work"> <a href="#scaling-mechanisms-that-work" class="anchor-heading" aria-labelledby="scaling-mechanisms-that-work"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Scaling Mechanisms that Work </h2> <ol> <li><strong>Ahead-of-time Identity Interpretation</strong> - pre-computed interpretations of variable/object identity to reduce amount of absurd interpretations</li> <li><strong>Automatic Side-Effect (ASE)</strong> - automatic proof that part of the definition has no effect on solution or plan and is safe to remove, reducing amount of objects/</li> <li><strong>Action schema splitting</strong> - Action schema optimization based on breaking down big action schemas into smaller schemas with smaller interpretation/grounding</li> <li>Domain and fact-space cleanup removes unused actions and facts prior to running “smarter” portions of the system.</li> <li>Caching of function interpretations skips some compilation and optimization steps</li> </ol> <h3 id="low-hanging-fruits"> <a href="#low-hanging-fruits" class="anchor-heading" aria-labelledby="low-hanging-fruits"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Low-hanging Fruits </h3> <ol> <li>Select only relevant records from the database</li> <li>Parallel symbolic execution</li> </ol> <h2 id="tested-methods-not-yet-in-production"> <a href="#tested-methods-not-yet-in-production" class="anchor-heading" aria-labelledby="tested-methods-not-yet-in-production"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Tested Methods not yet in Production </h2> <ol> <li>Machine learned partial grounding - reduces the search space by analyzing the existing plans and inferring additional knowledge about the domain. Shown to accelerate search by 1000x</li> <li>Genetic programming-based heuristic configuration optimization: Fast-downward, the underlying solver comes with a powerful search configuration language that allows construction of novel domain-specific heuristics. GP shown to accelerate by 1000x.</li> <li>Schema splitting optimization - configuring parameters of splitter function and heuristics to yield optimal grounding</li> <li>Reordering of preconditions [assign order scores to preconditions] - optimizing grounding path, splitter performance and search direction by reordering the precondtions</li> </ol> <h2 id="methods-from-literature-but-not-fully-tested-yet"> <a href="#methods-from-literature-but-not-fully-tested-yet" class="anchor-heading" aria-labelledby="methods-from-literature-but-not-fully-tested-yet"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Methods from literature but not fully tested yet </h2> <ol> <li>Schema modification using automatic proof a. Interpreted without data (ex. bound propagation) b. Interpreted with data (ex. ALEPH) c. [In between]</li> <li>Learning new proof methods / partial plans from solved plans</li> </ol> <h2 id="novel-work-not-in-production-yet"> <a href="#novel-work-not-in-production-yet" class="anchor-heading" aria-labelledby="novel-work-not-in-production-yet"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Novel Work not in production yet </h2> <ol> <li>Metaplanner - recursive planner that defines and loads the planning problem as a planning problem. Creates universal embedding for machine learning. Applicable for infinite recursion of many “meta-levels”</li> <li>Hinting - simplified machine learning embeddable in PDDL domain definition directly: calculate sets of objects that can be selected by a specific action and injects as preconditions. Requires stabilization of object hashes.</li> </ol> <h2 id="not-distant-future"> <a href="#not-distant-future" class="anchor-heading" aria-labelledby="not-distant-future"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Not-distant Future </h2> <ol> <li>Grounding mining. Some problems may never fit into computer memory or be optimally solved (for example the task of task optimization). Grounding mining is a partial groudnging approach that works like a combination of a lifted planning and machine learned grounding. Should be better than lifted planning and blind search. Should only be applied at meta level (for tasks of optimizing the tasks and search).</li> <li>Deep meta applications of the planner a. Searching for a heuristic for better heuristic… b. Optimizing the task optimizer for task optimizer…</li> </ol> <h1 id="remark-on-plan-optimality"> <a href="#remark-on-plan-optimality" class="anchor-heading" aria-labelledby="remark-on-plan-optimality"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Remark on Plan Optimality </h1> <p>HyperC aims at outperforming humans at planning problems. So we provide no guarantee of optimality of the plan, nor do we provide any safety of the solution. However, some modes include double-evaluation using Python so plan correctness can be asserted with high level of confidence.</p> <p>Thus HyperC is allowed to “cut corners” and “cheat” in order to find feasible solutions faster.</p> <hr> <footer> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/hyperc-ai/hyperc-ai-website/tree/master/scalability.markdown" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
